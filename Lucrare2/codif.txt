* ADD   //add x2,x1,x0

 - Summary   : Addition with 3 GPRs, no overflow exception
 - Assembly  : add rd, rs1, rs2
 - Semantics : R[rd] = R[rs1] + R[rs2]
 - Format    : R-type

  31        25 24     20 19     15 14  12 11      7 6           0
 +------------+---------+---------+------+---------+-------------+
 | 0000000    | rs2     | rs1     | 000  | rd      | 0110011     |
 +------------+---------+---------+------+---------+-------------+
 +------------+---------+---------+------+---------+-------------+
 | 0000000    | x0      | x1      | 000  | x2      | 0110011     |
 +------------+---------+---------+------+---------+-------------+
   0000000      00000     00001     000    00010     0110011

* ADDI   //addi x1,x1,1

 - Summary   : Add constant, no overflow exception
 - Assembly  : addi rd, rs1, imm
 - Semantics : R[rd] = R[rs1] + sext(imm)
 - Format    : I-type, I-immediate

  31                  20 19     15 14  12 11      7 6           0
 +----------------------+---------+------+---------+-------------+
 | imm                  | rs1     | 000  | rd      | 0010011     |
 +----------------------+---------+------+---------+-------------+
 +----------------------+---------+------+---------+-------------+
 | 1                    | x1      | 000  | x1      | 0010011     |
 +----------------------+---------+------+---------+-------------+
   000000000001           00001     000    00001     0010011

* AND   //and x3,x1,x2

 - Summary   : Bitwise logical AND with 3 GPRs
 - Assembly  : and rd, rs1, rs2
 - Semantics : R[rd] = R[rs1] & R[rs2]
 - Format    : R-type

  31        25 24     20 19     15 14  12 11      7 6           0
 +------------+---------+---------+------+---------+-------------+
 | 0000000    | rs2     | rs1     | 111  | rd      | 0110011     |
 +------------+---------+---------+------+---------+-------------+
 +------------+---------+---------+------+---------+-------------+
 | 0000000    | x2      | x1      | 111  | x3      | 0110011     |
 +------------+---------+---------+------+---------+-------------+
   0000000      00010     00001     111    00011     0110011

* ORI   //ori x4,x1,1

 - Summary   : Bitwise logical OR with constant
 - Assembly  : ori rd, rs1, imm
 - Semantics : R[rd] = R[rs1] | sext(imm)
 - Format    : I-type, I-immediate

  31                  20 19     15 14  12 11      7 6           0
 +----------------------+---------+------+---------+-------------+
 | imm                  | rs1     | 110  | rd      | 0010011     |
 +----------------------+---------+------+---------+-------------+
 +----------------------+---------+------+---------+-------------+
 | 1                    | x1      | 110  | x4      | 0010011     |
 +----------------------+---------+------+---------+-------------+
   000000000001           00001     110    00100     0010011   

* SW   //sw x4,4(x5)

 - Summary   : Store word into memory
 - Assembly  : sw rs2, imm(rs1)
 - Semantics : M_4B[ R[rs1] + sext(imm) ] = R[rs2]
 - Format    : S-type, S-immediate

  31        25 24     20 19     15 14  12 11      7 6           0
 +------------+---------+---------+------+---------+-------------+
 | imm        | rs2     | rs1     | 010  | imm     | 0100011     |
 +------------+---------+---------+------+---------+-------------+
 +------------+---------+---------+------+---------+-------------+
 | 4          | x4      | x5      | 010  | 4       | 0100011     |
 +------------+---------+---------+------+---------+-------------+
   0000000      00100     00101     010    00100     0100011

* LW   //lw x12,8(x0)

 - Summary   : Load word from memory
 - Assembly  : lw rd, imm(rs1)
 - Semantics : R[rd] = M_4B[ R[rs1] + sext(imm) ]
 - Format    : I-type, I-immediate

  31                  20 19     15 14  12 11      7 6           0
 +----------------------+---------+------+---------+-------------+
 | imm                  | rs1     | 010  | rd      | 0000011     |
 +----------------------+---------+------+---------+-------------+
 +----------------------+---------+------+---------+-------------+
 | 8                    | x0      | 010  | x12     | 0000011     |
 +----------------------+---------+------+---------+-------------+
   000000001000           00000     010    01100     0000011

* BEQ   //beq	x18,x0,5c

 - Summary   : Branch if 2 GPRs are equal
 - Assembly  : beq rs1, rs2, imm
 - Semantics : PC = ( R[rs1] == R[rs2] ) ? PC + sext(imm) : PC + 4
 - Format    : S-type, B-immediate

  31        25 24     20 19     15 14  12 11      7 6           0
 +------------+---------+---------+------+---------+-------------+
 | imm        | rs2     | rs1     | 000  | imm     | 1100011     |
 +------------+---------+---------+------+---------+-------------+
 +------------+---------+---------+------+---------+-------------+
 | 5c         | x0      | x18     | 000  | 5c      | 1100011     |
 +------------+---------+---------+------+---------+-------------+
   0000010      00000     10010     000    11100     1100011

00000000000000001000000100110011
00000000000100001000000010010011
00000000001000001111000110110011
00000000000100001110001000010011
00000000010000101010001000100011
00000000100000000010011000000011
00000100000010010000111001100011
